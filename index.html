<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Konstantin Pichugin - Full-Stack Developer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        /* Remove default cursor from all clickable elements */
        a, button, .section-number, .project-link, .contact-link, .section-indicator, .section-wheel {
            cursor: none !important;
        }

        html {
            scroll-snap-type: y mandatory;
            scroll-behavior: smooth;
            scroll-padding-top: 0;
        }

        body {
            background: #000000;
            font-family: 'Courier New', Courier, 'Consolas', 'Monaco', monospace;
            color: #00ff00;
            overflow-x: hidden;
            text-shadow: 0 0 5px rgba(0, 255, 0, 0.5);
            cursor: none; /* Hide default cursor */
            scrollbar-width: none; /* Firefox */
            -ms-overflow-style: none; /* IE and Edge */
        }

        body::-webkit-scrollbar {
            display: none !important; /* Chrome, Safari, Opera */
            width: 0 !important;
            height: 0 !important;
            background: transparent !important;
        }

        html {
            scrollbar-width: none; /* Firefox */
            -ms-overflow-style: none; /* IE and Edge */
        }

        html::-webkit-scrollbar {
            display: none !important; /* Chrome, Safari, Opera */
            width: 0 !important;
            height: 0 !important;
            background: transparent !important;
        }

        /* Hide scrollbar for all elements */
        * {
            scrollbar-width: none; /* Firefox */
            -ms-overflow-style: none; /* IE and Edge */
        }

        *::-webkit-scrollbar {
            display: none !important;
            width: 0 !important;
            height: 0 !important;
            background: transparent !important;
        }

        /* Additional fullscreen scrollbar hiding */
        html.fullscreen-active,
        html.fullscreen-active body {
            scrollbar-width: none !important;
            -ms-overflow-style: none !important;
        }

        html.fullscreen-active::-webkit-scrollbar,
        html.fullscreen-active body::-webkit-scrollbar {
            display: none !important;
            width: 0 !important;
            height: 0 !important;
            background: transparent !important;
        }

        /* Custom hacker green cursor - pointer style */
        .custom-cursor {
            position: fixed;
            width: 24px;
            height: 24px;
            pointer-events: none;
            z-index: 10000;
            transform: translate(0, 0);
            filter: drop-shadow(0 0 3px #00ff00) drop-shadow(0 0 6px #00ff00);
            transition: transform 0.1s ease-out;
            overflow: visible;
        }

        .custom-cursor svg {
            width: 100%;
            height: 100%;
            display: block;
        }

        .custom-cursor.hover {
            transform: translate(0, 0) scale(1.2);
        }

        .custom-cursor.click {
            transform: translate(0, 0) scale(0.9);
        }

        /* Hero Section */
        .hero-section {
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            position: relative;
            padding: 40px 20px;
        }

        .hero-title {
            color: #00ff00;
            font-size: 3rem;
            margin-bottom: 10px;
            text-shadow: 0 0 10px #00ff00, 0 0 20px #00ff00, 0 0 30px #00ff00;
            animation: terminal-glow 1.5s ease-in-out infinite alternate;
            text-align: center;
            font-weight: bold;
            position: relative;
            transition: transform 0.1s, opacity 0.1s, filter 0.1s;
        }

        .hero-title .neon-normal {
            color: #00ff00;
            text-shadow: 0 0 10px #00ff00, 0 0 20px #00ff00, 0 0 30px #00ff00;
            display: inline-block;
        }

        .hero-title .neon-burnt {
            color: #00ff00;
            text-shadow: 0 0 2px #00ff00;
            display: inline-block;
            opacity: 0.15;
            filter: brightness(0.2);
            transition: opacity 0.2s, filter 0.2s, color 0.2s, text-shadow 0.2s;
        }

        .hero-title .neon-burnt.lit {
            opacity: 1;
            color: #00ff00;
            text-shadow: 0 0 10px #00ff00, 0 0 20px #00ff00, 0 0 30px #00ff00;
            filter: brightness(1);
            animation: neon-blink-sequence 0.6s;
        }

        .hero-title.glitch-active {
            animation: terminal-glow 1.5s ease-in-out infinite alternate, glitch-flicker 0.3s steps(20);
        }

        .hero-title.glitch-active .neon-burnt {
            animation: glitch-flicker 0.3s steps(20);
        }

        @keyframes neon-blink-sequence {
            0% {
                opacity: 1;
                color: #00ff00;
                text-shadow: 0 0 10px #00ff00, 0 0 20px #00ff00, 0 0 30px #00ff00;
                filter: brightness(1);
            }
            15% {
                opacity: 0.3;
                color: #00ff41;
                text-shadow: 0 0 3px #00ff41;
                filter: brightness(0.4);
            }
            30% {
                opacity: 1;
                color: #00ff00;
                text-shadow: 0 0 10px #00ff00, 0 0 20px #00ff00, 0 0 30px #00ff00;
                filter: brightness(1);
            }
            45% {
                opacity: 0.25;
                color: #39ff14;
                text-shadow: 0 0 2px #39ff14;
                filter: brightness(0.35);
            }
            60% {
                opacity: 1;
                color: #00ff00;
                text-shadow: 0 0 10px #00ff00, 0 0 20px #00ff00, 0 0 30px #00ff00;
                filter: brightness(1);
            }
            100% {
                opacity: 1;
                color: #00ff00;
                text-shadow: 0 0 10px #00ff00, 0 0 20px #00ff00, 0 0 30px #00ff00;
                filter: brightness(1);
            }
        }

        .hero-subtitle {
            color: #00ff41;
            font-size: 1.2rem;
            margin-bottom: 40px;
            opacity: 0.9;
            text-align: center;
            text-shadow: 0 0 5px rgba(0, 255, 65, 0.5);
        }

        .status-banner {
            background: rgba(0, 255, 0, 0.05);
            backdrop-filter: blur(10px);
            border: 2px solid #00ff00;
            border-radius: 0;
            padding: 20px 40px;
            margin-bottom: 40px;
            text-align: center;
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.3), inset 0 0 20px rgba(0, 255, 0, 0.1);
        }

        .status-banner p {
            margin: 5px 0;
            color: #00ff00;
            font-size: 0.95rem;
            text-shadow: 0 0 5px rgba(0, 255, 0, 0.5);
        }

        h1 {
            color: #00ff00;
            font-size: 2.5rem;
            margin-bottom: 20px;
            text-shadow: 0 0 10px #00ff00, 0 0 20px #00ff00;
            animation: terminal-glow 1.5s ease-in-out infinite alternate;
            font-weight: bold;
        }

        h2 {
            color: #00ff00;
            font-size: 2rem;
            margin: 40px 0 20px 0;
            text-align: center;
            text-shadow: 0 0 10px rgba(0, 255, 0, 0.6);
            font-weight: bold;
        }

        h3 {
            color: #00ff41;
            font-size: 1.5rem;
            margin: 30px 0 15px 0;
            text-align: center;
            text-shadow: 0 0 5px rgba(0, 255, 65, 0.5);
        }

        @keyframes terminal-glow {
            from {
                text-shadow: 0 0 10px #00ff00, 0 0 20px #00ff00;
            }
            to {
                text-shadow: 0 0 15px #00ff00, 0 0 30px #00ff00, 0 0 40px #00ff00;
            }
        }

        @keyframes glitch-flicker {
            0% {
                transform: translate(0);
                opacity: 1;
                filter: hue-rotate(0deg) brightness(1);
                text-shadow: 0 0 10px #00ff00, 0 0 20px #00ff00, 0 0 30px #00ff00;
            }
            5% {
                transform: translate(-4px, 2px);
                opacity: 0.8;
                filter: hue-rotate(15deg) brightness(1.2);
                text-shadow: -4px 2px 10px #00ff00, -4px 2px 20px #00ff41, 0 0 30px #00ff00;
            }
            10% {
                transform: translate(4px, -2px);
                opacity: 0.85;
                filter: hue-rotate(-15deg) brightness(0.8);
                text-shadow: 4px -2px 10px #00ff00, 4px -2px 20px #39ff14, 0 0 30px #00ff00;
            }
            15% {
                transform: translate(-3px, -3px);
                opacity: 0.9;
                filter: hue-rotate(20deg) brightness(1.1);
                text-shadow: -3px -3px 10px #00ff00, -3px -3px 20px #00ff7f, 0 0 30px #00ff00;
            }
            20% {
                transform: translate(3px, 3px);
                opacity: 0.75;
                filter: hue-rotate(-20deg) brightness(0.7);
                text-shadow: 3px 3px 10px #00ff00, 3px 3px 20px #00ff41, 0 0 30px #00ff00;
            }
            25% {
                transform: translate(-5px, 0);
                opacity: 0.88;
                filter: hue-rotate(25deg) brightness(1.3);
                text-shadow: -5px 0 10px #00ff00, -5px 0 20px #00ff00, 0 0 30px #00ff00;
            }
            30% {
                transform: translate(5px, 0);
                opacity: 0.82;
                filter: hue-rotate(-25deg) brightness(0.6);
                text-shadow: 5px 0 10px #00ff00, 5px 0 20px #00ff00, 0 0 30px #00ff00;
            }
            35% {
                transform: translate(0, -4px);
                opacity: 0.92;
                filter: hue-rotate(10deg) brightness(1.1);
                text-shadow: 0 -4px 10px #00ff00, 0 -4px 20px #00ff00, 0 0 30px #00ff00;
            }
            40% {
                transform: translate(0, 4px);
                opacity: 0.78;
                filter: hue-rotate(-10deg) brightness(0.9);
                text-shadow: 0 4px 10px #00ff00, 0 4px 20px #00ff00, 0 0 30px #00ff00;
            }
            45% {
                transform: translate(-2px, 4px);
                opacity: 0.85;
                filter: hue-rotate(18deg) brightness(1.15);
                text-shadow: -2px 4px 10px #00ff00, -2px 4px 20px #00ff41, 0 0 30px #00ff00;
            }
            50% {
                transform: translate(2px, -4px);
                opacity: 0.9;
                filter: hue-rotate(-18deg) brightness(0.85);
                text-shadow: 2px -4px 10px #00ff00, 2px -4px 20px #39ff14, 0 0 30px #00ff00;
            }
            55% {
                transform: translate(-6px, 1px);
                opacity: 0.8;
                filter: hue-rotate(30deg) brightness(1.25);
                text-shadow: -6px 1px 10px #00ff00, -6px 1px 20px #00ff7f, 0 0 30px #00ff00;
            }
            60% {
                transform: translate(6px, -1px);
                opacity: 0.88;
                filter: hue-rotate(-30deg) brightness(0.75);
                text-shadow: 6px -1px 10px #00ff00, 6px -1px 20px #00ff00, 0 0 30px #00ff00;
            }
            65% {
                transform: translate(-1px, -5px);
                opacity: 0.83;
                filter: hue-rotate(12deg) brightness(1.05);
                text-shadow: -1px -5px 10px #00ff00, -1px -5px 20px #00ff41, 0 0 30px #00ff00;
            }
            70% {
                transform: translate(1px, 5px);
                opacity: 0.87;
                filter: hue-rotate(-12deg) brightness(0.95);
                text-shadow: 1px 5px 10px #00ff00, 1px 5px 20px #39ff14, 0 0 30px #00ff00;
            }
            75% {
                transform: translate(-4px, -2px);
                opacity: 0.81;
                filter: hue-rotate(22deg) brightness(1.2);
                text-shadow: -4px -2px 10px #00ff00, -4px -2px 20px #00ff7f, 0 0 30px #00ff00;
            }
            80% {
                transform: translate(4px, 2px);
                opacity: 0.89;
                filter: hue-rotate(-22deg) brightness(0.8);
                text-shadow: 4px 2px 10px #00ff00, 4px 2px 20px #00ff00, 0 0 30px #00ff00;
            }
            85% {
                transform: translate(-3px, 3px);
                opacity: 0.84;
                filter: hue-rotate(8deg) brightness(1.1);
                text-shadow: -3px 3px 10px #00ff00, -3px 3px 20px #00ff41, 0 0 30px #00ff00;
            }
            90% {
                transform: translate(3px, -3px);
                opacity: 0.86;
                filter: hue-rotate(-8deg) brightness(0.9);
                text-shadow: 3px -3px 10px #00ff00, 3px -3px 20px #39ff14, 0 0 30px #00ff00;
            }
            95% {
                transform: translate(-2px, 0);
                opacity: 0.91;
                filter: hue-rotate(5deg) brightness(1.05);
                text-shadow: -2px 0 10px #00ff00, -2px 0 20px #00ff00, 0 0 30px #00ff00;
            }
            100% {
                transform: translate(0);
                opacity: 1;
                filter: hue-rotate(0deg) brightness(1);
                text-shadow: 0 0 10px #00ff00, 0 0 20px #00ff00, 0 0 30px #00ff00;
            }
        }

        @keyframes cursor-blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0; }
        }

        .sphere-container {
            width: 600px;
            height: 600px;
            position: relative;
            margin: 0 auto;
        }

        .sphere {
            width: 100%;
            height: 100%;
            position: relative;
        }

        .tag {
            position: absolute;
            cursor: pointer;
        }

        /* Tag as dot (collapsed state) */
        .tag.dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            padding: 0;
            background: rgba(0, 255, 0, 0.8);
            border: 2px solid #00ff00;
            box-shadow: 0 0 10px rgba(0, 255, 0, 0.8), 0 0 20px rgba(0, 255, 0, 0.4);
            font-size: 0;
            white-space: nowrap;
            overflow: hidden;
            transform: translate(-50%, -50%);
            /* Remove transition from class - we control it via inline styles */
        }

        /* Tag as full text (expanded state in center) */
        .tag.expanded {
            left: 50% !important;
            top: 50% !important;
            padding: 12px 24px;
            background: rgba(0, 0, 0, 0.9);
            backdrop-filter: blur(10px);
            border: 2px solid #00ff00;
            border-radius: 0;
            color: #00ff00;
            font-weight: bold;
            font-size: 16px;
            white-space: nowrap;
            box-shadow: 0 0 30px rgba(0, 255, 0, 0.8), inset 0 0 20px rgba(0, 255, 0, 0.1);
            width: auto;
            height: auto;
            z-index: 100;
            transform: translate(-50%, -50%) scale(1.2);
            transition: all 1.5s cubic-bezier(0.4, 0, 0.2, 1);
            text-shadow: 0 0 5px #00ff00;
        }

        /* Category colors for dots - all green terminal variants */
        .infrastructure.dot {
            background: rgba(0, 255, 0, 0.8);
            border-color: #00ff00;
            box-shadow: 0 0 10px rgba(0, 255, 0, 0.8), 0 0 20px rgba(0, 255, 0, 0.4);
        }

        .infrastructure.expanded {
            border-color: #00ff00;
            color: #00ff00;
            box-shadow: 0 0 30px rgba(0, 255, 0, 0.8), inset 0 0 20px rgba(0, 255, 0, 0.1);
        }

        .cloud.dot {
            background: rgba(0, 255, 65, 0.8);
            border-color: #00ff41;
            box-shadow: 0 0 10px rgba(0, 255, 65, 0.8), 0 0 20px rgba(0, 255, 65, 0.4);
        }

        .cloud.expanded {
            border-color: #00ff41;
            color: #00ff41;
            box-shadow: 0 0 30px rgba(0, 255, 65, 0.8), inset 0 0 20px rgba(0, 255, 65, 0.1);
        }

        .backend.dot {
            background: rgba(57, 255, 20, 0.8);
            border-color: #39ff14;
            box-shadow: 0 0 10px rgba(57, 255, 20, 0.8), 0 0 20px rgba(57, 255, 20, 0.4);
        }

        .backend.expanded {
            border-color: #39ff14;
            color: #39ff14;
            box-shadow: 0 0 30px rgba(57, 255, 20, 0.8), inset 0 0 20px rgba(57, 255, 20, 0.1);
        }

        .frontend.dot {
            background: rgba(0, 255, 127, 0.8);
            border-color: #00ff7f;
            box-shadow: 0 0 10px rgba(0, 255, 127, 0.8), 0 0 20px rgba(0, 255, 127, 0.4);
        }

        .frontend.expanded {
            border-color: #00ff7f;
            color: #00ff7f;
            box-shadow: 0 0 30px rgba(0, 255, 127, 0.8), inset 0 0 20px rgba(0, 255, 127, 0.1);
        }

        /* Terminal Container */
        .terminal-container {
            height: 100px;
        }

        /* Scroll Animation - Terminal Style */
        .section {
            opacity: 0;
            transform: translateY(30px);
            transition: opacity 0.8s ease-out, transform 0.8s ease-out;
            height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            scroll-snap-align: start;
            scroll-snap-stop: always;
            overflow-y: auto;
        }

        .section.terminal-reveal {
            opacity: 1;
            transform: translateY(0);
        }

        .section-content {
            position: relative;
            overflow: hidden;
            width: 100%;
            max-width: 1200px;
            margin: 0 auto;
        }

        .section-content::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 0;
            height: 100%;
            background: linear-gradient(90deg, rgba(0, 255, 0, 0.15) 0%, transparent 100%);
            pointer-events: none;
            z-index: 1;
        }

        .section.terminal-reveal .section-content::before {
            animation: terminal-scan 1.2s ease-out forwards;
        }

        @keyframes terminal-scan {
            0% {
                width: 0;
                opacity: 0;
            }
            50% {
                opacity: 0.4;
            }
            100% {
                width: 100%;
                opacity: 0;
            }
        }

        /* Terminal typing effect */
        .typing-element {
            position: relative;
        }

        .typing-element::after {
            content: '_';
            color: #00ff00;
            animation: cursor-blink 1s infinite;
            margin-left: 2px;
        }

        .typing-element.typing-complete::after {
            display: none;
        }

        .typing-text {
            opacity: 0;
        }

        .typing-text.typing-active {
            opacity: 1;
        }

        /* Section Indicator - iOS style wheel */
        .section-indicator {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 1000;
            font-family: 'Courier New', Courier, 'Consolas', 'Monaco', monospace;
            color: #00ff00;
            text-shadow: 0 0 10px rgba(0, 255, 0, 0.8);
            transition: all 0.3s ease-out;
        }

        @media (max-width: 768px) {
            .section-indicator {
                top: 10px;
                right: 10px;
                transform: scale(0.8);
                display: flex;
                flex-direction: column;
                align-items: center;
            }
            
            .section-wheel {
                width: 140px;
                height: 60px;
            }

            .section-number {
                height: 30px;
                line-height: 30px;
                font-size: 7px;
                padding: 0 5px;
            }

            .section-number.active {
                font-size: 9px;
            }

            .section-number.inactive {
                font-size: 6px;
            }

            .section-indicator-label {
                font-size: 8px;
                margin-bottom: 3px;
            }

            /* Ensure sections have padding to avoid overlap */
            .section {
                padding-top: 80px;
            }

            .hero-section {
                padding-top: 80px;
            }
        }

        @media (max-width: 480px) {
            .control-buttons {
                top: 5px;
                left: 5px;
                align-items: center;
            }
            
            .section-indicator {
                top: 5px;
                right: 5px;
                transform: scale(0.7);
                display: flex;
                align-items: center;
            }

            .section-wheel {
                width: 120px;
                height: 50px;
            }

            .section-number {
                height: 25px;
                line-height: 25px;
                font-size: 6px;
                padding: 0 3px;
            }

            .section-number.active {
                font-size: 8px;
            }

            .section-number.inactive {
                font-size: 5px;
            }

            .section-indicator-label {
                font-size: 7px;
                margin-bottom: 2px;
            }

            /* More padding for very small screens */
            .section {
                padding-top: 70px;
            }

            .hero-section {
                padding-top: 70px;
            }
        }

        .section-indicator:hover {
            z-index: 1001;
        }

        /* Control buttons container */
        .control-buttons {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 1000;
            display: flex;
            gap: 10px;
            font-family: 'Courier New', Courier, 'Consolas', 'Monaco', monospace;
        }

        @media (max-width: 768px) {
            .control-buttons {
                top: 10px;
                left: 10px;
                gap: 8px;
                align-items: center;
            }
            
            .control-button {
                padding: 6px 12px;
                font-size: 10px;
            }
            
            /* Hide fullscreen button on mobile, show only sound button */
            #fullscreen-btn {
                display: none;
            }
        }

        .control-button {
            padding: 8px 16px;
            background: rgba(0, 0, 0, 0.95);
            border: 2px solid #00ff00;
            color: #00ff00;
            font-size: 12px;
            font-weight: bold;
            cursor: none;
            text-shadow: 0 0 10px rgba(0, 255, 0, 0.8);
            transition: all 0.3s ease-out;
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.5), inset 0 0 20px rgba(0, 255, 0, 0.1);
            user-select: none;
        }

        .control-button:hover {
            background: rgba(0, 255, 0, 0.1);
            box-shadow: 0 0 30px rgba(0, 255, 0, 0.8), inset 0 0 30px rgba(0, 255, 0, 0.2);
            transform: translateY(-2px);
        }

        .control-button:active {
            transform: translateY(0);
            box-shadow: 0 0 15px rgba(0, 255, 0, 0.6), inset 0 0 15px rgba(0, 255, 0, 0.15);
        }

        .control-button.muted {
            border-color: #ff4444;
            color: #ff4444;
            text-shadow: 0 0 10px rgba(255, 68, 68, 0.8);
            box-shadow: 0 0 20px rgba(255, 68, 68, 0.5), inset 0 0 20px rgba(255, 68, 68, 0.1);
        }

        .control-button.muted:hover {
            background: rgba(255, 68, 68, 0.1);
            box-shadow: 0 0 30px rgba(255, 68, 68, 0.8), inset 0 0 30px rgba(255, 68, 68, 0.2);
        }

        .section-indicator-label {
            font-size: 10px;
            color: #00ff41;
            text-align: center;
            margin-bottom: 5px;
            opacity: 0.7;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .section-wheel {
            position: relative;
            width: 180px;
            height: 80px;
            overflow: hidden;
            border: 2px solid #00ff00;
            background: rgba(0, 0, 0, 0.95);
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.5), inset 0 0 20px rgba(0, 255, 0, 0.1);
            transition: height 0.3s ease-out, box-shadow 0.3s ease-out;
        }

        .section-indicator:hover .section-wheel {
            height: auto;
            max-height: none;
            overflow-y: auto;
            overflow-x: hidden;
            box-shadow: 0 0 30px rgba(0, 255, 0, 0.8), inset 0 0 30px rgba(0, 255, 0, 0.2);
        }

        .section-indicator:hover .section-wheel-mask {
            display: none;
        }

        /* Scrollbar styling for expanded wheel */
        .section-wheel::-webkit-scrollbar {
            width: 8px;
        }

        .section-wheel::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.8);
            border-left: 1px solid rgba(0, 255, 0, 0.3);
        }

        .section-wheel::-webkit-scrollbar-thumb {
            background: #00ff00;
            box-shadow: 0 0 5px rgba(0, 255, 0, 0.8), inset 0 0 3px rgba(0, 255, 0, 0.5);
        }

        .section-wheel::-webkit-scrollbar-thumb:hover {
            background: #00ff41;
            box-shadow: 0 0 10px rgba(0, 255, 0, 1), inset 0 0 5px rgba(0, 255, 0, 0.7);
        }

        .section-wheel-mask {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
            background: linear-gradient(
                to bottom,
                rgba(0, 0, 0, 0.9) 0%,
                transparent 20%,
                transparent 80%,
                rgba(0, 0, 0, 0.9) 100%
            );
            z-index: 2;
        }

        .section-wheel-numbers {
            position: relative;
            width: 100%;
            transition: transform 0.2s ease-out;
        }

        /* When wheel is expanded, don't transform numbers */
        .section-indicator:hover .section-wheel-numbers {
            transform: none !important;
            position: relative;
        }

        .section-number {
            height: 40px;
            line-height: 40px;
            text-align: center;
            font-size: 9px;
            font-weight: bold;
            color: #00ff00;
            text-shadow: 0 0 10px rgba(0, 255, 0, 0.8);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            padding: 0 8px;
            letter-spacing: 0.5px;
            cursor: none;
            transition: background 0.2s ease-out, opacity 0.2s ease-out;
            user-select: none;
        }

        .section-number:hover {
            background: rgba(0, 255, 0, 0.1);
            opacity: 1 !important;
            text-shadow: 0 0 15px rgba(0, 255, 0, 1);
        }

        .section-number.active {
            color: #00ff00;
            text-shadow: 0 0 15px rgba(0, 255, 0, 1), 0 0 25px rgba(0, 255, 0, 0.6);
            font-size: 11px;
            letter-spacing: 0.8px;
        }

        .section-number.inactive {
            opacity: 0.3;
            font-size: 7px;
            letter-spacing: 0.3px;
        }

        /* Particles background */
        .particle {
            position: fixed;
            width: 2px;
            height: 2px;
            background: rgba(0, 255, 0, 0.6);
            border-radius: 50%;
            animation: float 10s linear infinite;
            pointer-events: none;
            z-index: 1;
            box-shadow: 0 0 5px rgba(0, 255, 0, 0.8);
        }

        @keyframes float {
            0%, 100% {
                transform: translate(0, 0);
                opacity: 0;
            }
            10% {
                opacity: 1;
            }
            90% {
                opacity: 1;
            }
            100% {
                transform: translate(var(--tx), var(--ty));
                opacity: 0;
            }
        }

        .legend {
            margin-top: 40px;
            display: flex;
            justify-content: center;
            gap: 30px;
            flex-wrap: wrap;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px 16px;
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid #00ff00;
            border-radius: 0;
            backdrop-filter: blur(10px);
            box-shadow: 0 0 10px rgba(0, 255, 0, 0.3);
        }

        .legend-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
        }

        .legend-text {
            color: #00ff00;
            font-size: 14px;
            font-weight: bold;
            text-shadow: 0 0 5px rgba(0, 255, 0, 0.5);
        }

        /* Section Styles */
        .section {
            padding: 60px 20px;
            max-width: 1200px;
            margin: 0 auto;
            position: relative;
            z-index: 10;
        }

        /* Override section height for hero section */
        .hero-section {
            height: auto;
            min-height: 100vh;
            scroll-snap-align: start;
        }

        .section-content {
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(10px);
            border-radius: 0;
            padding: 40px;
            border: 2px solid #00ff00;
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.3), inset 0 0 20px rgba(0, 255, 0, 0.05);
        }

        /* Stats Section */
        .stats-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin: 30px 0;
        }

        .stat-card {
            background: rgba(0, 0, 0, 0.9);
            border: 1px solid #00ff00;
            border-radius: 0;
            padding: 20px;
            text-align: center;
            transition: all 0.3s ease;
            color: #00ff00;
        }

        .stat-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.6), inset 0 0 20px rgba(0, 255, 0, 0.1);
            border-color: #00ff00;
        }

        .stat-card img {
            width: 100%;
            border-radius: 10px;
        }

        /* Projects Grid */
        .projects-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 30px;
            margin: 30px 0;
        }

        .project-card {
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid #00ff00;
            border-radius: 0;
            padding: 25px;
            transition: all 0.3s ease;
        }

        .project-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.6), inset 0 0 20px rgba(0, 255, 0, 0.1);
            border-color: #00ff00;
        }

        .project-card h3 {
            color: #00ff00;
            margin-bottom: 10px;
            font-size: 1.3rem;
            text-shadow: 0 0 5px rgba(0, 255, 0, 0.5);
        }

        .project-card p {
            color: #00ff41;
            margin-bottom: 15px;
            line-height: 1.6;
        }

        .project-link {
            display: inline-block;
            padding: 10px 20px;
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid #00ff00;
            border-radius: 0;
            cursor: none;
            color: #00ff00;
            text-decoration: none;
            transition: all 0.3s ease;
            font-weight: bold;
            text-shadow: 0 0 5px rgba(0, 255, 0, 0.5);
        }

        .project-link:hover {
            background: rgba(0, 255, 0, 0.1);
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.8);
        }

        .tech-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-top: 15px;
        }

        .tech-tag {
            padding: 5px 12px;
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid #00ff00;
            border-radius: 0;
            font-size: 0.85rem;
            color: #00ff00;
            text-shadow: 0 0 3px rgba(0, 255, 0, 0.5);
        }

        /* Achievements Grid */
        .achievements-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 20px;
            margin: 30px 0;
        }

        .achievement-card {
            background: rgba(0, 0, 0, 0.9);
            border: 1px solid #00ff00;
            border-radius: 0;
            padding: 20px;
            text-align: center;
            transition: all 0.3s ease;
            color: #00ff00;
        }

        .achievement-card:hover {
            transform: scale(1.05);
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.6), inset 0 0 20px rgba(0, 255, 0, 0.1);
        }

        .achievement-card img {
            width: 48px;
            height: 48px;
            margin-bottom: 10px;
        }

        /* Philosophy Cards */
        .philosophy-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 30px;
            margin: 30px 0;
        }

        .philosophy-card {
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid #00ff00;
            border-radius: 0;
            padding: 30px;
            text-align: center;
            transition: all 0.3s ease;
        }

        .philosophy-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.6), inset 0 0 20px rgba(0, 255, 0, 0.1);
            border-color: #00ff00;
        }

        .philosophy-card h3 {
            color: #00ff00;
            margin-bottom: 15px;
            text-shadow: 0 0 5px rgba(0, 255, 0, 0.5);
        }

        .philosophy-card p {
            color: #00ff41;
            font-style: italic;
            line-height: 1.6;
        }

        .quote {
            margin: 30px 0;
            padding: 20px;
            background: rgba(0, 0, 0, 0.9);
            border-left: 4px solid #00ff00;
            border-radius: 0;
            font-style: italic;
            color: #00ff41;
            font-size: 1.1rem;
            box-shadow: 0 0 10px rgba(0, 255, 0, 0.2);
        }

        /* Contact Section */
        .contact-grid {
            display: flex;
            justify-content: center;
            gap: 30px;
            flex-wrap: wrap;
            margin: 30px 0;
        }

        .contact-link {
            padding: 15px 30px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #00ff00;
            border-radius: 0;
            color: #00ff00;
            cursor: none;
            text-decoration: none;
            font-weight: bold;
            transition: all 0.3s ease;
            display: inline-block;
            text-shadow: 0 0 5px rgba(0, 255, 0, 0.5);
        }

        .contact-link:hover {
            background: rgba(0, 255, 0, 0.1);
            box-shadow: 0 0 25px rgba(0, 255, 0, 0.8);
            transform: translateY(-3px);
        }

        /* Footer */
        .footer {
            text-align: center;
            padding: 40px 20px;
            color: #00ff41;
            border-top: 2px solid #00ff00;
            margin-top: 60px;
            text-shadow: 0 0 5px rgba(0, 255, 65, 0.5);
        }

        .divider {
            height: 2px;
            background: linear-gradient(90deg, transparent, rgba(0, 255, 0, 0.5), transparent);
            margin: 40px 0;
            box-shadow: 0 0 10px rgba(0, 255, 0, 0.3);
        }

        /* Responsive */
        @media (max-width: 768px) {
            .hero-title {
                font-size: 1.8rem;
                line-height: 1.2;
            }
            
            .hero-subtitle {
                font-size: 0.9rem;
            }
            
            .status-banner {
                padding: 15px 20px;
                margin-bottom: 20px;
            }
            
            .status-banner p {
                font-size: 0.75rem;
                margin: 3px 0;
            }
            
            .terminal-container {
                padding: 15px;
                height: auto;
                min-height: 80px;
            }

            .section {
                padding: 20px 15px;
                min-height: 100vh;
                height: auto;
            }

            .section-content {
                padding: 20px 15px;
                padding-top: 80px; /* Extra padding to avoid overlap with section indicator */
            }

            .hero-section {
                padding: 80px 15px 40px;
                min-height: 100vh;
            }

            h1 {
                font-size: 1.8rem;
                margin-bottom: 15px;
            }

            h2 {
                font-size: 1.3rem;
                margin: 20px 0 15px 0;
            }
            
            h3 {
                font-size: 1.1rem;
                margin: 15px 0 10px 0;
            }
            
            h4 {
                font-size: 0.95rem;
            }
            
            p, .tech-tag, .legend-text {
                font-size: 0.85rem;
            }
            
            .projects-grid,
            .philosophy-grid,
            .stats-container {
                grid-template-columns: 1fr;
                gap: 15px;
                margin: 20px 0;
            }
            
            .achievements-grid {
                grid-template-columns: repeat(2, 1fr);
                gap: 10px;
                margin: 20px 0;
            }
            
            .project-card,
            .philosophy-card,
            .stat-card {
                padding: 15px;
            }
            
            .achievement-card {
                padding: 10px;
            }
            
            .achievement-card img {
                width: 32px;
                height: 32px;
                margin-bottom: 8px;
            }
            
            .achievement-card h4 {
                font-size: 0.75rem;
                margin: 8px 0 4px 0;
            }
            
            .achievement-card p {
                font-size: 0.7rem;
            }
            
            .legend {
                gap: 10px;
                margin-top: 20px;
            }
            
            .legend-item {
                padding: 6px 12px;
                gap: 8px;
            }
            
            .legend-dot {
                width: 10px;
                height: 10px;
            }
            
            .legend-text {
                font-size: 0.75rem;
            }
            
            .contact-grid {
                flex-direction: column;
                gap: 15px;
            }
            
            .contact-link {
                width: 100%;
                text-align: center;
            }
            
            .quote {
                padding: 15px;
                font-size: 0.9rem;
                margin: 20px 0;
            }
            
            .tech-tags {
                gap: 6px;
                margin-top: 10px;
            }
            
            .tech-tag {
                padding: 4px 10px;
                font-size: 0.75rem;
            }
            
            .divider {
                margin: 20px 0;
            }
        }
        
        @media (max-width: 480px) {
            .hero-title {
                font-size: 1.5rem;
            }
            
            .hero-subtitle {
                font-size: 0.8rem;
            }
            
            .status-banner {
                padding: 12px 15px;
            }
            
            .status-banner p {
                font-size: 0.7rem;
            }
            
            h2 {
                font-size: 1.1rem;
            }
            
            h3 {
                font-size: 0.95rem;
            }
            
            p, .tech-tag, .legend-text {
                font-size: 0.8rem;
            }
            
            .section-content {
                padding: 15px 10px;
                padding-top: 70px; /* Extra padding for section indicator */
            }
            
            .hero-section {
                padding-top: 70px; /* Extra padding for section indicator */
            }
            
            .project-card,
            .philosophy-card {
                padding: 12px;
            }
            
            .achievement-card {
                padding: 8px;
            }
            
            .achievement-card img {
                width: 28px;
                height: 28px;
                margin-bottom: 6px;
            }
            
            .achievement-card h4 {
                font-size: 0.7rem;
                margin: 6px 0 3px 0;
            }
            
            .achievement-card p {
                font-size: 0.65rem;
            }
            
            .achievements-grid {
                grid-template-columns: repeat(2, 1fr);
                gap: 8px;
            }
            
            .legend {
                gap: 8px;
            }
            
            .legend-item {
                padding: 5px 10px;
            }
            
            .legend-text {
                font-size: 0.7rem;
            }
        }

        /* iPhone 14 Pro Max specific styles */
        @media only screen and (min-device-width: 428px) and (max-device-width: 430px) and (orientation: portrait) {
            .hero-title {
                font-size: 1.6rem;
                line-height: 1.3;
            }
            
            .hero-subtitle {
                font-size: 0.85rem;
            }
            
            .status-banner {
                padding: 12px 18px;
                margin-bottom: 25px;
            }
            
            .status-banner p {
                font-size: 0.72rem;
            }
            
            .section-content {
                padding: 18px 12px;
                padding-top: 75px;
            }
            
            .hero-section {
                padding: 75px 12px 35px;
            }
            
            h2 {
                font-size: 1.25rem;
            }
            
            h3 {
                font-size: 1.05rem;
            }
            
            .project-card,
            .philosophy-card,
            .achievement-card {
                padding: 14px;
            }
        }

        @media only screen and (min-device-width: 428px) and (max-device-width: 430px) and (orientation: landscape) {
            .hero-title {
                font-size: 1.4rem;
            }
            
            .hero-subtitle {
                font-size: 0.8rem;
            }
            
            .section-content {
                padding: 15px 10px;
                padding-top: 70px;
            }
            
            .hero-section {
                padding: 70px 10px 30px;
            }
            
            h2 {
                font-size: 1.2rem;
            }
            
            h3 {
                font-size: 1rem;
            }
            
            .projects-grid,
            .philosophy-grid,
            .achievements-grid {
                grid-template-columns: repeat(2, 1fr);
                gap: 12px;
            }
        }

        /* Typing Animation Container */
        .typing-container {
            text-align: center;
            padding: 20px;
            margin: 30px 0;
        }

        .typing-container img {
            max-width: 100%;
        }

        /* Terminal cursor effect */
        .terminal-cursor::after {
            content: '_';
            animation: cursor-blink 1s infinite;
            color: #00ff00;
            text-shadow: 0 0 10px #00ff00;
        }

        /* Terminal scanline effect */
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(
                transparent 50%,
                rgba(0, 255, 0, 0.03) 50%
            );
            background-size: 100% 4px;
            pointer-events: none;
            z-index: 9999;
            animation: scanline 8s linear infinite;
        }

        @keyframes scanline {
            0% { transform: translateY(0); }
            100% { transform: translateY(4px); }
        }
    </style>
</head>
<body>
    <!-- Control Buttons (Desktop only) -->
    <div class="control-buttons">
        <button class="control-button" id="fullscreen-btn" title="Toggle Fullscreen">[FULLSCREEN]</button>
        <button class="control-button" id="mute-btn" title="Toggle Sound">[SOUND ON]</button>
    </div>

    <!-- Section Indicator -->
    <div class="section-indicator">
        <div class="section-indicator-label">Section</div>
        <div class="section-wheel">
            <div class="section-wheel-mask"></div>
            <div class="section-wheel-numbers" id="section-wheel-numbers">
                <div class="section-number active" data-index="0">HOME</div>
                <div class="section-number inactive" data-index="1">TECH ARSENAL</div>
                <div class="section-number inactive" data-index="2">METRICS</div>
                <div class="section-number inactive" data-index="3">PROJECTS</div>
                <div class="section-number inactive" data-index="4">FOCUS</div>
                <div class="section-number inactive" data-index="5">ACHIEVEMENTS</div>
                <div class="section-number inactive" data-index="6">CONTRIBUTIONS</div>
                <div class="section-number inactive" data-index="7">PHILOSOPHY</div>
                <div class="section-number inactive" data-index="8">CONTACTS</div>
            </div>
        </div>
    </div>

    <!-- Hero Section with 3D Sphere -->
    <section class="hero-section">
        <h1 class="hero-title">
            <span class="neon-normal">KONST</span><span class="neon-burnt">ANTIN</span> <span class="neon-normal">PIC</span><span class="neon-burnt">HUGIN</span>
        </h1>
        <p class="hero-subtitle">Full-Stack Beginner Developer | DevOps Engineer</p>
        
        <div class="status-banner">
            <p>DIVING DEEP INTO THE CODE OCEAN</p>
            <p>+ Status: Building the future, one commit at a time</p>
            <p>! Location: Tula, Russia | Remote: Worldwide</p>
            <p># Current Vibe: High Performance | Precision Engineering</p>
        </div>


        <div class="terminal-container">
            <div class="terminal-header">
                <span class="terminal-prompt">$</span>
                <span class="terminal-user">root@expertise</span>
                <span class="terminal-path">~/tech-stack</span>
            </div>
            <div class="terminal-command" id="terminal-command">
                <span id="command-text"></span>
                <span class="terminal-cursor"></span>
            </div>
            <div class="terminal-output" id="terminal-output"></div>
        </div>
        <div class="legend">
            <div class="legend-item">
                <div class="legend-dot" style="background: #00ff00;"></div>
                <span class="legend-text">Infrastructure</span>
            </div>
            <div class="legend-item">
                <div class="legend-dot" style="background: #00ff41;"></div>
                <span class="legend-text">Cloud & DevOps</span>
            </div>
            <div class="legend-item">
                <div class="legend-dot" style="background: #39ff14;"></div>
                <span class="legend-text">Backend</span>
            </div>
            <div class="legend-item">
                <div class="legend-dot" style="background: #00ff7f;"></div>
                <span class="legend-text">Frontend</span>
            </div>
        </div>
    </section>


    <!-- Technology Arsenal Section -->
    <section class="section">
        <div class="section-content">
            <h2>TECHNOLOGY ARSENAL</h2>
                <h3>CORE STACK</h3>
            
            <div style="margin: 30px 0;">
                <h4 style="color: #00ff00; margin-bottom: 15px; text-shadow: 0 0 5px rgba(0, 255, 0, 0.5);">Backend Engineering</h4>
                <div style="display: flex; justify-content: center; gap: 15px; flex-wrap: wrap; margin-bottom: 30px;">
                    <span class="tech-tag">Node.js</span>
                    <span class="tech-tag">Python</span>
                    <span class="tech-tag">Go</span>
                    <span class="tech-tag">Rust</span>
                </div>
                <p style="text-align: center; color: #00ff41; margin-bottom: 20px;">
                    <strong>Python</strong> - Advanced | <strong>Go</strong> - Proficient
                </p>
    </div>

            <div style="margin: 30px 0;">
                    <h4 style="color: #00ff00; margin-bottom: 15px; text-shadow: 0 0 5px rgba(0, 255, 0, 0.5);">Infrastructure & DevOps</h4>
                <div style="display: flex; justify-content: center; gap: 15px; flex-wrap: wrap; margin-bottom: 30px;">
                    <span class="tech-tag">Docker</span>
                    <span class="tech-tag">Kubernetes</span>
                    <span class="tech-tag">Linux</span>
                    <span class="tech-tag">Nginx</span>
                    <span class="tech-tag">AWS</span>
                    <span class="tech-tag">Azure</span>
                </div>
                <p style="text-align: center; color: #00ff41; margin-bottom: 20px;">
                    <strong>Docker</strong> - Master | <strong>Nginx</strong> - Middle | <strong>Linux</strong> - Wizard
                </p>
            </div>

            <div style="margin: 30px 0;">
                    <h4 style="color: #00ff00; margin-bottom: 15px; text-shadow: 0 0 5px rgba(0, 255, 0, 0.5);">Frontend Craft</h4>
                <div style="display: flex; justify-content: center; gap: 15px; flex-wrap: wrap; margin-bottom: 30px;">
                    <span class="tech-tag">TypeScript</span>
                    <span class="tech-tag">React</span>
                    <span class="tech-tag">Next.js</span>
                    <span class="tech-tag">Tailwind</span>
                    <span class="tech-tag">Vite</span>
                </div>
                <p style="text-align: center; color: #00ff41;">
                    <strong>TypeScript</strong> - Advanced | <strong>React</strong> - Proficient
                </p>
            </div>
        </div>
    </section>


    <!-- Performance Metrics Section -->
    <section class="section">
        <div class="section-content">
            <h2>PERFORMANCE METRICS</h2>
            <div class="stats-container">
                <div class="stat-card">
                    <img src="https://github-readme-activity-graph.vercel.app/graph?username=konstpic&custom_title=Contribution%20Flow&bg_color=000000&color=00ff00&line=00ff00&point=00ff41&area=true&hide_border=true&area_color=00ff41" alt="Contribution Graph"/>
                </div>
            </div>
        </div>
    </section>


    <!-- Signature Projects Section -->
    <section class="section">
        <div class="section-content">
            <h2>SIGNATURE PROJECTS</h2>
            <div class="projects-grid">
                <div class="project-card">
                    <h3>3x-ui MySQL Fork</h3>
                    <p>Advanced proxy management system with MySQL backend integration</p>
                    <a href="https://github.com/konstpic/3x-ui-MySQL-fork" class="project-link" target="_blank">VIEW REPO</a>
                    <div class="tech-tags">
                        <span class="tech-tag">Node.js</span>
                        <span class="tech-tag">MySQL</span>
                        <span class="tech-tag">Docker</span>
                        <span class="tech-tag">Nginx</span>
                    </div>
                </div>
                <div class="project-card">
                    <h3>Nginx Balancer</h3>
                    <p>High-performance load balancing solution for distributed systems</p>
                    <a href="https://github.com/konstpic/nginx-balancer" class="project-link" target="_blank">VIEW REPO</a>
                    <div class="tech-tags">
                        <span class="tech-tag">Nginx</span>
                        <span class="tech-tag">Linux</span>
                        <span class="tech-tag">DevOps</span>
                        <span class="tech-tag">Networking</span>
                    </div>
                </div>
            </div>
        </div>
    </section>


    <!-- Current Focus Areas Section -->
    <section class="section">
        <div class="section-content">
            <h2>CURRENT FOCUS AREAS</h2>
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 20px; margin: 30px 0;">
                <div class="philosophy-card">
                    <h3 style="color: #ff6b6b;">Infrastructure</h3>
                    <p>Load Balancing<br/>Proxy Architecture<br/>Network Optimization<br/>High Availability</p>
                </div>
                <div class="philosophy-card">
                    <h3 style="color: #8a2be2;">Cloud Native</h3>
                    <p>Kubernetes<br/>Microservices<br/>Container Orchestration<br/>CI/CD Pipelines</p>
                </div>
                <div class="philosophy-card">
                    <h3 style="color: #00ff88;">Backend Development</h3>
                    <p>API Design<br/>Database Optimization<br/>Performance Tuning<br/>Security Hardening</p>
                </div>
                <div class="philosophy-card">
                    <h3 style="color: #ffd700;">DevOps Culture</h3>
                    <p>Automation<br/>Monitoring<br/>IaC<br/>GitOps</p>
                </div>
            </div>
        </div>
    </section>


    <!-- Achievements Section -->
    <section class="section">
        <div class="section-content">
            <h2>ACHIEVEMENTS UNLOCKED</h2>
            <div class="achievements-grid">
                <div class="achievement-card">
                    <img src="https://raw.githubusercontent.com/devicons/devicon/master/icons/github/github-original.svg" alt="commits"/>
                    <h4 style="color: #00ff00; margin: 10px 0 5px 0; text-shadow: 0 0 5px rgba(0, 255, 0, 0.5);">Commits</h4>
                    <p style="color: #00ff41; font-size: 0.9rem;">Building Daily</p>
                </div>
                <div class="achievement-card">
                    <img src="https://cdn.jsdelivr.net/gh/devicons/devicon/icons/docker/docker-original.svg" alt="docker"/>
                    <h4 style="color: #00ff00; margin: 10px 0 5px 0; text-shadow: 0 0 5px rgba(0, 255, 0, 0.5);">Containerization</h4>
                    <p style="color: #00ff41; font-size: 0.9rem;">Master</p>
                </div>
                <div class="achievement-card">
                    <img src="https://cdn.jsdelivr.net/gh/devicons/devicon/icons/linux/linux-original.svg" alt="linux"/>
                    <h4 style="color: #00ff00; margin: 10px 0 5px 0; text-shadow: 0 0 5px rgba(0, 255, 0, 0.5);">Linux Guru</h4>
                    <p style="color: #00ff41; font-size: 0.9rem;">Middle Level</p>
                </div>
                <div class="achievement-card">
                    <img src="https://cdn.jsdelivr.net/gh/devicons/devicon/icons/nginx/nginx-original.svg" alt="nginx"/>
                    <h4 style="color: #00ff00; margin: 10px 0 5px 0; text-shadow: 0 0 5px rgba(0, 255, 0, 0.5);">Load Balancing</h4>
                    <p style="color: #00ff41; font-size: 0.9rem;">Middle Level</p>
                </div>
                <div class="achievement-card">
                    <img src="https://cdn.jsdelivr.net/gh/devicons/devicon/icons/nodejs/nodejs-original.svg" alt="nodejs"/>
                    <h4 style="color: #00ff00; margin: 10px 0 5px 0; text-shadow: 0 0 5px rgba(0, 255, 0, 0.5);">Backend Dev</h4>
                    <p style="color: #00ff41; font-size: 0.9rem;">Middle Level</p>
                </div>
            </div>
            <div style="display: flex; justify-content: center; gap: 15px; flex-wrap: wrap; margin-top: 30px;">
                <span class="tech-tag" style="font-size: 1rem; padding: 10px 20px;">Total Stars: Counting</span>
                <span class="tech-tag" style="font-size: 1rem; padding: 10px 20px;">Streak: Active</span>
                <span class="tech-tag" style="font-size: 1rem; padding: 10px 20px;">Projects: Multiple</span>
                <span class="tech-tag" style="font-size: 1rem; padding: 10px 20px;">Status: Shipping</span>
            </div>
        </div>
    </section>


    <!-- Contribution Flow Section -->
    <section class="section">
        <div class="section-content">
            <h2>CONTRIBUTION FLOW</h2>
            <div style="margin: 30px 0;">
                <img src="https://raw.githubusercontent.com/konstpic/konstpic/output/github-contribution-grid-snake-dark.svg" alt="Contribution Snake" style="width: 100%; max-width: 800px; margin: 0 auto; display: block;"/>
            </div>
        </div>
    </section>


    <!-- Engineering Philosophy Section -->
    <section class="section">
        <div class="section-content">
            <h2>ENGINEERING PHILOSOPHY</h2>
            <div class="philosophy-grid">
                <div class="philosophy-card">
                    <h3>PRECISION</h3>
                    <p>Every line of code<br/>serves a purpose</p>
                </div>
                <div class="philosophy-card">
                    <h3>PERFORMANCE</h3>
                    <p>Optimize for speed<br/>and efficiency</p>
                </div>
                <div class="philosophy-card">
                    <h3>SECURITY</h3>
                    <p>Build systems<br/>that last</p>
                </div>
            </div>
            <div class="quote">
                "The best code is no code. The second best code is simple, elegant, and maintainable."
            </div>
        </div>
    </section>



    <!-- Contact Section -->
    <section class="section">
        <div class="section-content">
            <h2>TRANSMISSION CHANNELS</h2>
            <div class="contact-grid">
                <a href="https://github.com/konstpic" class="contact-link" target="_blank">GitHub</a>
                <a href="https://t.me/konstpic" class="contact-link" target="_blank">Telegram</a>
            </div>
            <p style="text-align: center; margin-top: 30px; color: #00ff41;">
                <strong>Open for Collaboration</strong><br/>
                <span style="color: #00ff41; opacity: 0.8;">Interesting Projects  Infrastructure Challenges  Open Source Contributions</span>
            </p>
            <div style="text-align: center; margin-top: 60px; padding-top: 40px; border-top: 2px solid #00ff00;">
                <p style="font-size: 1.2rem; margin-bottom: 10px; color: #00ff00;">"In code we trust, in automation we thrive"</p>
                <p style="color: #00ff41; opacity: 0.8;">Made with passion and dedication by Konstantin Pichugin</p>
            </div>
        </div>
    </section>

    <script>
        // Sound effects using Web Audio API for reliable programmatic sound generation
        let audioContext;
        let initSoundPlayed = false;
        let soundMuted = false;
        let initSoundMasterGain = null; // Master gain node for init sound volume control
        let neonBlinkSound = null; // Sound for neon blink effect (HTMLAudioElement)
        let neonBlinkBuffer = null; // AudioBuffer for neon blink sound (for reverb)
        let neonBlinkSource = null; // MediaElementSource for neon blink sound
        let keyClickBuffer = null; // AudioBuffer for keyboard click sound
        let backgroundMusic = null; // Background music
        let reverbConvolver = null; // Reverb effect
        let reverbGain = null; // Reverb gain control
        let reverbAmount = 0.2; // Reverb amount (0.2 = 20% default)
        
        function initSounds() {
            try {
                // Initialize Web Audio API context
                const AudioContextClass = window.AudioContext || window.webkitAudioContext;
                if (AudioContextClass) {
                    audioContext = new AudioContextClass();
                    
                    // Create master gain node for init sound with lower volume
                    initSoundMasterGain = audioContext.createGain();
                    initSoundMasterGain.gain.value = 0.1; // Reduce init sound volume to 60%1
                    initSoundMasterGain.connect(audioContext.destination);
                    
                    // Create reverb effect first (needed for neon sound)
                    createReverbEffect();
                    
                    // Initialize neon blink sound
                    // Use HTMLAudioElement directly (works with file:// protocol, no CORS issues)
                    neonBlinkSound = new Audio('media/sound_lamp.mp3');
                    neonBlinkSound.volume = 0.08;
                    neonBlinkSound.preload = 'auto';
                    
                    // Note: Both sounds use HTMLAudioElement directly (works with file:// protocol)
                    // AudioBuffer loading functions are available but not used for file:// compatibility
                    // loadNeonBlinkSound(); // Only works with http/https, not file://
                    // loadKeyClickSound(); // Only works with http/https, not file://
                    
                    // Initialize background music
                    backgroundMusic = new Audio('media/background.mp3');
                    backgroundMusic.volume = 0.01; // 10% volume
                    backgroundMusic.loop = true; // Loop infinitely
                    backgroundMusic.preload = 'auto';
                    
                    // Try to resume audio context immediately (may require user interaction)
                    if (audioContext.state === 'suspended') {
                        audioContext.resume().catch(() => {
                            // Will be resumed on user interaction
                        });
                    }
                }
            } catch (e) {
                console.log('Web Audio API not available:', e);
            }
        }
        
        // Function to activate audio context and play init sound
        function activateAudioAndPlayInit() {
            if (!audioContext) {
                initSounds();
            }
            
            // Ensure master gain is created
            if (audioContext && !initSoundMasterGain) {
                initSoundMasterGain = audioContext.createGain();
                initSoundMasterGain.gain.value = 0.1; // Reduce init sound volume to 10%
                initSoundMasterGain.connect(audioContext.destination);
            }
            
            if (audioContext) {
                // Resume audio context if suspended
                if (audioContext.state === 'suspended') {
                    audioContext.resume().then(() => {
                        if (!initSoundPlayed) {
                            playInitSound();
                        }
                    }).catch(() => {
                        // Silent fail - will retry on next interaction
                    });
                } else {
                    if (!initSoundPlayed) {
                        playInitSound();
                    }
                }
            }
        }

        function createInitSound() {
            if (!audioContext) return null;
            
            try {
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.connect(gainNode);
                // Connect through master gain node for volume control
                if (initSoundMasterGain) {
                    gainNode.connect(initSoundMasterGain);
                } else {
                    gainNode.connect(audioContext.destination);
                }
                
                // Create a startup/initialization sound: short and simple like typing sound
                oscillator.type = 'sine'; // Softer than square wave
                oscillator.frequency.setValueAtTime(550, audioContext.currentTime);
                oscillator.frequency.exponentialRampToValueAtTime(200, audioContext.currentTime + 0.03);
                
                gainNode.gain.setValueAtTime(0, audioContext.currentTime);
                // Lower base gain - master gain (0.1) will multiply this
                // Final volume: 0.03 * 0.1 = 0.003 (much quieter)
                gainNode.gain.linearRampToValueAtTime(0.03, audioContext.currentTime + 0.002);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.04);
                
                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + 0.04);
                
                return oscillator;
            } catch (e) {
                console.log('Failed to create init sound:', e);
                return null;
            }
        }

        // Load neon blink sound as AudioBuffer (only works with http/https, not file://)
        // Note: Currently not used - we use HTMLAudioElement directly for file:// compatibility
        async function loadNeonBlinkSound() {
            if (!audioContext) return;
            
            // Only try to load if we're in a web context (not file://)
            if (window.location.protocol === 'file:') {
                return; // Skip loading for file:// protocol
            }
            
            try {
                const response = await fetch('media/sound_lamp.mp3');
                const arrayBuffer = await response.arrayBuffer();
                neonBlinkBuffer = await audioContext.decodeAudioData(arrayBuffer);
                console.log('Neon blink sound loaded as AudioBuffer');
            } catch (e) {
                // Silent fail - will use HTMLAudioElement fallback
            }
        }
        
        // Load key click sound as AudioBuffer (only works with http/https, not file://)
        async function loadKeyClickSound() {
            if (!audioContext) return;
            
            // Only try to load if we're in a web context (not file://)
            if (window.location.protocol === 'file:') {
                // Skip loading for file:// protocol - will use HTMLAudioElement fallback
                return;
            }
            
            try {
                const response = await fetch('media/key_click.mp3');
                const arrayBuffer = await response.arrayBuffer();
                keyClickBuffer = await audioContext.decodeAudioData(arrayBuffer);
                console.log('Key click sound loaded as AudioBuffer');
            } catch (e) {
                console.log('Failed to load key click sound as AudioBuffer:', e);
            }
        }
        
        // Play neon blink sound (using HTMLAudioElement - works with file:// protocol)
        function playNeonBlinkSoundWithReverb() {
            if (soundMuted || !neonBlinkSound) return;
            
            // Use HTMLAudioElement directly (works with file:// protocol)
            // Note: Reverb is not available with HTMLAudioElement, but sound will work
            try {
                neonBlinkSound.currentTime = 0;
                neonBlinkSound.play().catch(() => {
                    // Silent fail if audio context not ready
                });
            } catch (e) {
                console.log('Failed to play neon blink sound:', e);
            }
        }
        
        // Create reverb effect using ConvolverNode
        function createReverbEffect() {
            if (!audioContext) return;
            
            try {
                // Create a simple impulse response for reverb
                const sampleRate = audioContext.sampleRate;
                const length = sampleRate * 2; // 2 seconds
                const impulse = audioContext.createBuffer(2, length, sampleRate);
                
                // Generate impulse response (exponential decay)
                for (let channel = 0; channel < 2; channel++) {
                    const channelData = impulse.getChannelData(channel);
                    for (let i = 0; i < length; i++) {
                        const n = length - i;
                        channelData[i] = (Math.random() * 2 - 1) * Math.pow(n / length, 2);
                    }
                }
                
                // Create convolver and gain nodes
                reverbConvolver = audioContext.createConvolver();
                reverbConvolver.buffer = impulse;
                
                reverbGain = audioContext.createGain();
                reverbGain.gain.value = reverbAmount;
                
                reverbConvolver.connect(reverbGain);
                reverbGain.connect(audioContext.destination);
            } catch (e) {
                console.log('Failed to create reverb effect:', e);
            }
        }
        
        // Set reverb amount in percentage (0-100)
        function setReverbAmount(percentage) {
            reverbAmount = Math.max(0, Math.min(1, percentage / 100));
            if (reverbGain) {
                reverbGain.gain.value = reverbAmount;
            }
            // Update neon blink sound reverb mix if connected
            // Note: We need to store references to gain nodes to update them
            if (neonBlinkSource && neonBlinkSound._neonDryGain && neonBlinkSound._neonWetGain) {
                neonBlinkSound._neonDryGain.gain.value = 1 - reverbAmount;
                neonBlinkSound._neonWetGain.gain.value = reverbAmount;
            }
        }
        
        function createTypingSound() {
            // Always use HTMLAudioElement for key_click.mp3 (works with file:// protocol)
            // This allows pitch and volume variations without CORS issues
            try {
                const sound = new Audio('media/key_click.mp3');
                
                // Random pitch variation to simulate different typing force
                // Pitch range: 0.85 to 1.15 (85% to 115% of original speed)
                // Lower pitch = heavier press, higher pitch = lighter press
                const pitchVariation = 0.85 + Math.random() * 0.3; // 0.85 to 1.15
                sound.playbackRate = pitchVariation;
                
                // Volume variation based on "typing force" (inverse of pitch)
                // Heavier press (lower pitch) = louder, lighter press (higher pitch) = quieter
                const volumeVariation = 0.4 + (1.15 - pitchVariation) * 0.3; // 0.4 to 0.85
                sound.volume = volumeVariation;
                
                sound.play().catch(() => {
                    // Silent fail if audio context not ready
                });
                
                return sound;
            } catch (e) {
                console.log('Failed to create typing sound:', e);
                return null;
            }
        }

        function playInitSound() {
            if (initSoundPlayed || soundMuted) return;
            
            try {
                // Resume audio context if suspended
                if (audioContext && audioContext.state === 'suspended') {
                    audioContext.resume().then(() => {
                        createInitSound();
                        initSoundPlayed = true;
                    }).catch(() => {
                        // Silent fail - audio will activate on next user interaction
                    });
                } else {
                    createInitSound();
                    initSoundPlayed = true;
                }
            } catch (e) {
                // Silent fail - audio will activate on next user interaction
            }
        }

        function playTypingSound() {
            if (soundMuted) return;
            
            // Simply create and play the sound - HTMLAudioElement works without Web Audio API
            // and works with file:// protocol
            createTypingSound();
        }


        const technologies = [
            // Infrastructure
            { text: 'Docker', class: 'infrastructure', command: 'docker ps' },
            { text: 'Nginx', class: 'infrastructure', command: 'nginx -t' },
            { text: 'Linux', class: 'infrastructure', command: 'uname -a' },
            { text: 'Load Balancing', class: 'infrastructure', command: 'haproxy -c' },
            { text: 'Proxy', class: 'infrastructure', command: 'squid -k check' },
            { text: 'Network Engineering', class: 'infrastructure', command: 'ip addr show' },
            
            // Cloud & DevOps
            { text: 'AWS', class: 'cloud', command: 'aws s3 ls' },
            { text: 'Azure', class: 'cloud', command: 'az account show' },
            { text: 'Kubernetes', class: 'cloud', command: 'kubectl get nodes' },
            { text: 'CI/CD', class: 'cloud', command: 'gitlab-ci validate' },
            { text: 'Automation', class: 'cloud', command: 'ansible-playbook --check' },
            { text: 'Monitoring', class: 'cloud', command: 'prometheus --version' },
            
            // Backend
            { text: 'Node.js', class: 'backend', command: 'node --version' },
            { text: 'Python', class: 'backend', command: 'python --version' },
            { text: 'Go', class: 'backend', command: 'go version' },
            { text: 'API Design', class: 'backend', command: 'curl -I api.example.com' },
            { text: 'Microservices', class: 'backend', command: 'docker-compose ps' },
            { text: 'Database', class: 'backend', command: 'psql --version' },
            
            // Frontend
            { text: 'TypeScript', class: 'frontend', command: 'tsc --version' },
            { text: 'React', class: 'frontend', command: 'npm list react' },
            { text: 'Next.js', class: 'frontend', command: 'next --version' },
            { text: 'Tailwind', class: 'frontend', command: 'npx tailwindcss --version' },
            { text: 'Performance', class: 'frontend', command: 'lighthouse --version' },
            { text: 'UX Engineering', class: 'frontend', command: 'npm run build' }
        ];

        const commandText = document.getElementById('command-text');
        const terminalOutput = document.getElementById('terminal-output');
        let currentTechIndex = 0;
        let isTyping = false;
        
        // Track active typing animations to prevent overlapping sounds
        let activeTypingTimers = new Set();
        let currentTypingSection = null;
        
        // Track neon blink timers to stop them when switching sections
        let activeNeonBlinkTimers = new Set();
        
        // Track terminal animation timers to stop them when switching sections
        let terminalTimers = new Set();
        let terminalAnimationActive = false;
        let terminalSectionIndex = -1; // Track which section has terminal active

        // Typewriter effect
        function typeText(element, text, speed = 100, callback) {
            if (isTyping) return;
            isTyping = true;
            element.textContent = '';
            let index = 0;
            let timerId = null;
            let isCancelled = false;
            
            function type() {
                // Check if terminal animation was stopped (for terminal only)
                if (element === commandText && !terminalAnimationActive) {
                    isCancelled = true;
                    isTyping = false;
                    return;
                }
                
                if (isCancelled) {
                    if (timerId) {
                        activeTypingTimers.delete(timerId);
                    }
                    return;
                }
                
                if (index < text.length) {
                    const char = text[index];
                    element.textContent += char;
                    
                    // Play typing sound only for non-space characters
                    if (char !== ' ') {
                        playTypingSound();
                    }
                    
                    index++;
                    
                    // Faster typing for spaces (no sound), slower for regular characters
                    const charSpeed = char === ' ' ? speed * 0.3 : speed + Math.random() * 30;
                    timerId = setTimeout(type, charSpeed);
                    activeTypingTimers.add(timerId);
                } else {
                    if (timerId) {
                        activeTypingTimers.delete(timerId);
                    }
                    isTyping = false;
                    if (callback) callback();
                }
            }
            
            // Store cancel function on element for later cleanup
            element._cancelTyping = () => {
                isCancelled = true;
                if (timerId) {
                    clearTimeout(timerId);
                    activeTypingTimers.delete(timerId);
                }
                isTyping = false;
            };
            
            type();
        }

        // Show technology in terminal
        function showTechnology(index) {
            // Don't continue if terminal animation was stopped
            if (!terminalAnimationActive) return;
            
            const tech = technologies[index];
            
            // Clear output
            terminalOutput.innerHTML = '';
            
            // Type command
            typeText(commandText, tech.command, 100, () => {
                // Don't continue if terminal animation was stopped
                if (!terminalAnimationActive) return;
                
                // Wait a bit, then show output
                const timer1 = setTimeout(() => {
                    if (!terminalAnimationActive) return;
                    
                    const outputLine = document.createElement('div');
                    outputLine.style.marginTop = '10px';
                    outputLine.innerHTML = `<span style="color: #00ff41;"></span> <span class="terminal-tech ${tech.class}">${tech.text}</span>`;
                    terminalOutput.appendChild(outputLine);
                    
                    // Wait before next tech
                    const timer2 = setTimeout(() => {
                        if (!terminalAnimationActive) return;
                        currentTechIndex = (currentTechIndex + 1) % technologies.length;
                        showTechnology(currentTechIndex);
                        terminalTimers.delete(timer2);
                    }, 2000);
                    terminalTimers.add(timer2);
                    terminalTimers.delete(timer1);
                }, 500);
                terminalTimers.add(timer1);
            });
        }

        // Create particles
        for (let i = 0; i < 50; i++) {
            const particle = document.createElement('div');
            particle.className = 'particle';
            particle.style.left = Math.random() * 100 + '%';
            particle.style.top = Math.random() * 100 + '%';
            particle.style.setProperty('--tx', (Math.random() - 0.5) * 200 + 'px');
            particle.style.setProperty('--ty', (Math.random() - 0.5) * 200 + 'px');
            particle.style.animationDelay = Math.random() * 10 + 's';
            document.body.appendChild(particle);
        }

        // Terminal animation will be started by handleSectionChange when hero-section is active
        // Don't start automatically to avoid conflicts

        // Terminal typing effect function
        function typeText(element, text, speed = 100, callback) {
            if (!element || !text) return;
            
            element.textContent = '';
            element.classList.add('typing-element');
            element.classList.remove('typing-complete');
            element.style.opacity = '1';
            
            let index = 0;
            let timerId = null;
            let isCancelled = false;
            
            function type() {
                // Check if animation was cancelled
                if (isCancelled) {
                    if (timerId) {
                        activeTypingTimers.delete(timerId);
                    }
                    return;
                }
                
                if (index < text.length) {
                    const char = text[index];
                    element.textContent += char;
                    
                    // Play typing sound only for non-space characters
                    if (char !== ' ') {
                        playTypingSound();
                    }
                    
                    index++;
                    
                    // Faster typing for spaces (no sound), slower for regular characters
                    const charSpeed = char === ' ' ? speed * 0.3 : speed + Math.random() * 30;
                    timerId = setTimeout(type, charSpeed);
                    activeTypingTimers.add(timerId);
                } else {
                    if (timerId) {
                        activeTypingTimers.delete(timerId);
                    }
                    element.classList.add('typing-complete');
                    element.classList.remove('typing-element');
                    if (callback) callback();
                }
            }
            
            // Store cancel function on element for later cleanup
            element._cancelTyping = () => {
                isCancelled = true;
                if (timerId) {
                    clearTimeout(timerId);
                    activeTypingTimers.delete(timerId);
                }
            };
            
            type();
        }
        
        // Stop all sounds (typing sounds and neon blink sound) without stopping animations
        function stopAllSounds() {
            // Stop neon blink sound if playing
            if (neonBlinkSound) {
                try {
                    neonBlinkSound.pause();
                    neonBlinkSound.currentTime = 0;
                } catch (e) {
                    // Silent fail
                }
            }
            // Note: Typing sounds are created on-the-fly and don't need to be stopped
            // They will automatically stop when typing animation stops
        }
        
        // Stop all active typing animations
        function stopAllTypingAnimations() {
            // Clear all active timers
            activeTypingTimers.forEach(timerId => {
                clearTimeout(timerId);
            });
            activeTypingTimers.clear();
            
            // Cancel all active typing animations on elements
            document.querySelectorAll('[data-original-text], .typing-element').forEach(element => {
                if (element._cancelTyping) {
                    element._cancelTyping();
                }
                // Remove typing classes
                element.classList.remove('typing-element');
                element.classList.add('typing-complete');
            });
            
            // Stop sounds when switching sections
            stopAllSounds();
            
            // Stop terminal animation when switching sections
            stopTerminalAnimation();
        }
        
        // Stop terminal animation
        function stopTerminalAnimation() {
            // Stop terminal animation flag
            terminalAnimationActive = false;
            terminalSectionIndex = -1;
            
            // Clear all terminal timers
            terminalTimers.forEach(timerId => {
                clearTimeout(timerId);
            });
            terminalTimers.clear();
            
            // Stop typing animation in terminal if active
            if (commandText) {
                if (commandText._cancelTyping) {
                    commandText._cancelTyping();
                }
            }
            
            // Reset typing state
            isTyping = false;
        }
        
        // Stop neon blink effect
        function stopNeonBlinkEffect() {
            // Clear all neon blink timers
            activeNeonBlinkTimers.forEach(timerId => {
                clearTimeout(timerId);
            });
            activeNeonBlinkTimers.clear();
            
            // Remove lit class from all neon-burnt elements
            document.querySelectorAll('.neon-burnt').forEach(element => {
                element.classList.remove('lit');
            });
            
            // Stop neon sound if playing
            if (neonBlinkSound) {
                try {
                    neonBlinkSound.pause();
                    neonBlinkSound.currentTime = 0;
                } catch (e) {
                    // Silent fail
                }
            }
            // Note: AudioBufferSourceNode sources are one-shot and don't need to be stopped
        }

        // Store original text content for typing animation
        function prepareTypingElements(section) {
            // Prepare main headings and paragraphs
            // Exclude section indicator elements from typing animation
            const textElements = section.querySelectorAll('h2, h3, h4, p:not(.project-card p):not(.philosophy-card p):not(.achievement-card p)');
            
            textElements.forEach((element) => {
                // Skip if element is inside section indicator
                if (element.closest('.section-indicator')) return;
                
                if (element.dataset.originalText === undefined) {
                    element.dataset.originalText = element.textContent.trim();
                    element.textContent = '';
                    element.style.opacity = '0';
                }
            });

            // Prepare card headers and hide cards initially
            const cardHeaders = section.querySelectorAll('.project-card h3, .philosophy-card h3, .achievement-card h4');
            const cards = section.querySelectorAll('.project-card, .philosophy-card, .achievement-card, .stat-card');
            
            cardHeaders.forEach((header) => {
                if (header.dataset.originalText === undefined) {
                    header.dataset.originalText = header.textContent.trim();
                    header.textContent = '';
                }
            });

            cards.forEach((card) => {
                card.style.opacity = '0';
                card.style.transform = 'translateX(-20px)';
            });
        }

        // Type all text elements in sequence
        function typeSectionContent(section) {
            // Stop any previous typing animations
            if (currentTypingSection && currentTypingSection !== section) {
                stopAllTypingAnimations();
            }
            currentTypingSection = section;
            
            // Get all text elements in order
            const mainTextElements = Array.from(section.querySelectorAll('h2, h3:not(.project-card h3):not(.philosophy-card h3):not(.achievement-card h4), h4:not(.achievement-card h4), p:not(.project-card p):not(.philosophy-card p):not(.achievement-card p)')).filter(el => el.dataset.originalText);
            
            // Get card headers
            const cardHeaders = Array.from(section.querySelectorAll('.project-card h3, .philosophy-card h3, .achievement-card h4')).filter(el => el.dataset.originalText);
            
            // Combine and sort by DOM order
            const allTextElements = [...mainTextElements, ...cardHeaders].sort((a, b) => {
                const position = a.compareDocumentPosition(b);
                return position & Node.DOCUMENT_POSITION_FOLLOWING ? -1 : 1;
            });

            const processedCards = new Set();
            let currentElementIndex = 0;

            // Function to type next element sequentially
            function typeNextElement() {
                // Check if we've typed all elements
                if (currentElementIndex >= allTextElements.length) {
                    // Show other elements after all text is typed
                    setTimeout(() => {
                        const otherElements = section.querySelectorAll('.stat-card, .contact-link, .stats-container, .projects-grid, .achievements-grid, .philosophy-grid, .contact-grid');
                        otherElements.forEach((el, idx) => {
                            setTimeout(() => {
                                el.style.opacity = '1';
                                el.style.transform = 'translateX(0)';
                                el.style.transition = 'opacity 0.3s ease-out, transform 0.3s ease-out';
                            }, idx * 50);
                        });
                    }, 200);
                    return;
                }

                const element = allTextElements[currentElementIndex];
                const originalText = element.dataset.originalText;
                const typingSpeed = 100; // Unified speed for all elements
                
                // Type current element, then move to next
                typeText(element, originalText, typingSpeed, () => {
                    // Show card after its header is typed
                    const parentCard = element.closest('.project-card, .philosophy-card, .achievement-card');
                    if (parentCard && !processedCards.has(parentCard)) {
                        processedCards.add(parentCard);
                        setTimeout(() => {
                            parentCard.style.opacity = '1';
                            parentCard.style.transform = 'translateX(0)';
                            parentCard.style.transition = 'opacity 0.3s ease-out, transform 0.3s ease-out';
                        }, 100);
                    }
                    
                    // Small delay before next element starts typing
                    setTimeout(() => {
                        currentElementIndex++;
                        typeNextElement();
                    }, 150);
                });
            }

            // Start typing first element
            typeNextElement();

            // Show other elements (stat cards, links, grids) after text typing
            setTimeout(() => {
                const otherElements = section.querySelectorAll('.stat-card, .contact-link, .stats-container, .projects-grid, .achievements-grid, .philosophy-grid, .contact-grid');
                otherElements.forEach((el, idx) => {
                    setTimeout(() => {
                        el.style.opacity = '1';
                        el.style.transform = 'translateX(0)';
                        el.style.transition = 'opacity 0.3s ease-out, transform 0.3s ease-out';
                    }, idx * 50);
                });
            }, delay);
        }

        // Scroll animation - Terminal style reveal with typing
        // Only observe .section elements, not .hero-section
        const sections = document.querySelectorAll('.section:not(.hero-section)');
        
        // Adaptive threshold based on screen size
        const isMobile = window.innerWidth <= 768;
        const observerOptions = {
            threshold: isMobile ? 0.5 : 0.95, // Lower threshold for mobile (50% vs 95%)
            rootMargin: isMobile ? '0px' : '0px'
        };

        // IntersectionObserver is now disabled - section animations are controlled by scroll events
        // This allows proper handling of snap scroll behavior
        // sections.forEach((section) => {
        //     revealObserver.observe(section);
        // });

        // Enhanced snap scroll - aggressive section switching
        let isScrolling = false;
        let scrollTimeout;
        let wheelDelta = 0;
        let lastWheelTime = 0;

        function getCurrentSectionIndex() {
            // Get all sections including hero-section
            const heroSection = document.querySelector('.hero-section');
            const regularSections = Array.from(document.querySelectorAll('.section:not(.hero-section)'));
            const allSections = heroSection ? [heroSection, ...regularSections] : regularSections;
            
            if (allSections.length === 0) return 0;
            
            const viewportHeight = window.innerHeight;
            const scrollY = window.scrollY || window.pageYOffset;
            const viewportCenter = scrollY + (viewportHeight / 2);
            
            // Simple logic: find which section's center is closest to viewport center
            let currentIndex = 0;
            let minDistance = Infinity;
            
            allSections.forEach((section, index) => {
                const rect = section.getBoundingClientRect();
                const sectionCenter = rect.top + scrollY + (rect.height / 2);
                const distance = Math.abs(viewportCenter - sectionCenter);
                
                if (distance < minDistance) {
                    minDistance = distance;
                    currentIndex = index;
                }
            });
            
            return currentIndex;
        }

        function scrollToSection(index, direction = 0) {
            if (isScrolling) return;
            
            // Get all sections including hero-section
            const heroSection = document.querySelector('.hero-section');
            const regularSections = Array.from(document.querySelectorAll('.section:not(.hero-section)'));
            const allSections = heroSection ? [heroSection, ...regularSections] : regularSections;
            
            if (index < 0) index = 0;
            if (index >= allSections.length) index = allSections.length - 1;
            
            const targetSection = allSections[index];
            if (!targetSection) return;
            
            // Update current section index immediately to prevent double handling
            previousSectionIndex = currentSectionIndex;
            currentSectionIndex = index;
            
            // Handle section change (animations will be managed by scroll handler)
            handleSectionChange(index, previousSectionIndex);
            
            // Update section indicator
            updateSectionIndicator(index);
            
            isScrolling = true;
            targetSection.scrollIntoView({ 
                behavior: 'smooth', 
                block: 'start' 
            });
            
            clearTimeout(scrollTimeout);
            scrollTimeout = setTimeout(() => {
                isScrolling = false;
                // After scroll completes, verify current section and handle if needed
                const actualIndex = getCurrentSectionIndex();
                if (actualIndex !== currentSectionIndex) {
                    previousSectionIndex = currentSectionIndex;
                    currentSectionIndex = actualIndex;
                    handleSectionChange(actualIndex, previousSectionIndex);
                    updateSectionIndicator(actualIndex);
                }
            }, 600);
        }

        // Get short section title for wheel display
        function getSectionTitle(section) {
            if (section.classList.contains('hero-section')) {
                return 'HOME';
            }
            const h2 = section.querySelector('h2');
            if (!h2) return 'Section';
            
            const fullTitle = h2.textContent.trim();
            
            // Map full titles to short versions for wheel
            const titleMap = {
                'TECHNOLOGY ARSENAL': 'TECH ARSENAL',
                'PERFORMANCE METRICS': 'METRICS',
                'SIGNATURE PROJECTS': 'PROJECTS',
                'CURRENT FOCUS AREAS': 'FOCUS',
                'ACHIEVEMENTS UNLOCKED': 'ACHIEVEMENTS',
                'CONTRIBUTION FLOW': 'CONTRIBUTIONS',
                'ENGINEERING PHILOSOPHY': 'PHILOSOPHY',
                'TRANSMISSION CHANNELS': 'CONTACTS'
            };
            
            return titleMap[fullTitle] || fullTitle;
        }

        // Simple section indicator update - just bind to scroll
        function updateSectionIndicator(currentIndex) {
            const wheelNumbers = document.getElementById('section-wheel-numbers');
            if (!wheelNumbers) return;
            
            // Get all section number elements
            const sectionNumbers = Array.from(wheelNumbers.querySelectorAll('.section-number'));
            
            // Update active/inactive classes
            sectionNumbers.forEach((el, index) => {
                if (index === currentIndex) {
                    el.classList.add('active');
                    el.classList.remove('inactive');
                } else {
                    el.classList.add('inactive');
                    el.classList.remove('active');
                }
            });
            
            // Only apply transform when wheel is not expanded (not hovered)
            const sectionIndicator = document.querySelector('.section-indicator');
            if (sectionIndicator && !sectionIndicator.matches(':hover')) {
                const itemHeight = 40;
                const wheelHeight = 80;
                const offset = (wheelHeight / 2) - ((currentIndex * itemHeight) + (itemHeight / 2));
                wheelNumbers.style.transform = `translateY(${offset}px)`;
            } else {
                wheelNumbers.style.transform = 'none';
            }
        }

        // Initialize section indicator - simple initialization
        function initSectionIndicator() {
            const currentIndex = getCurrentSectionIndex();
            updateSectionIndicator(currentIndex);
        }

        // Manual wheel handling - only switch when user explicitly scrolls
        window.addEventListener('wheel', (e) => {
            // Don't prevent default - allow normal scrolling
            // Only snap when user stops scrolling
            
            const now = Date.now();
            const timeDelta = now - lastWheelTime;
            lastWheelTime = now;
            
            // Accumulate wheel delta
            wheelDelta += e.deltaY;
            
            // Reset delta if too much time passed or direction changed
            if (timeDelta > 200 || (wheelDelta > 0 && e.deltaY < 0) || (wheelDelta < 0 && e.deltaY > 0)) {
                wheelDelta = e.deltaY;
            }
            
            // Clear any pending snap
            clearTimeout(wheelTimeout);
            
            // Only snap after user stops scrolling
            wheelTimeout = setTimeout(() => {
                if (Math.abs(wheelDelta) > 100 && !isScrolling) {
                    const heroSection = document.querySelector('.hero-section');
                    const regularSections = Array.from(document.querySelectorAll('.section:not(.hero-section)'));
                    const allSections = heroSection ? [heroSection, ...regularSections] : regularSections;
                    
                    const currentIndex = getCurrentSectionIndex();
                    const direction = wheelDelta > 0 ? 1 : -1;
                    let nextIndex = currentIndex + direction;
                    
                    // Clamp to valid range
                    nextIndex = Math.max(0, Math.min(nextIndex, allSections.length - 1));
                    
                    // Only switch if index changed
                    if (nextIndex !== currentIndex) {
                        scrollToSection(nextIndex, direction);
                    }
                }
                wheelDelta = 0;
            }, 300); // Wait 300ms after last wheel event
        }, { passive: true });
        
        let wheelTimeout;

        // Initialize glitch effect for hero title
        function initGlitchEffect() {
            const heroTitle = document.querySelector('.hero-title');
            if (!heroTitle) return;
            
            function triggerGlitch() {
                heroTitle.classList.add('glitch-active');
                setTimeout(() => {
                    heroTitle.classList.remove('glitch-active');
                }, 300); // Duration of glitch animation
            }
            
            // Trigger glitch periodically (every 3-6 seconds randomly)
            function scheduleNextGlitch() {
                const delay = 3000 + Math.random() * 3000; // 3-6 seconds
                setTimeout(() => {
                    triggerGlitch();
                    scheduleNextGlitch();
                }, delay);
            }
            
            // Start after initial delay
            setTimeout(() => {
                scheduleNextGlitch();
            }, 2000);
        }

        // Initialize asynchronous neon blink effect for burnt parts (only in hero-section)
        function initNeonBlinkEffect() {
            // Only work in hero-section
            const heroSection = document.querySelector('.hero-section');
            if (!heroSection) return;
            
            const burntParts = heroSection.querySelectorAll('.hero-title .neon-burnt');
            if (burntParts.length === 0) return;
            
            // Function to trigger lighting sequence (2-3 blinks, then turn off)
            function triggerLight(element) {
                // Check if element is still in hero-section (prevent triggering on other sections)
                const heroSection = document.querySelector('.hero-section');
                if (!heroSection || !heroSection.contains(element)) {
                    return;
                }
                
                const blinkCount = 2 + Math.floor(Math.random() * 2); // 2 or 3 blinks
                let currentBlink = 0;
                
                // Play neon blink sound only if in hero-section
                if (!soundMuted && heroSection && heroSection.contains(element)) {
                    // Use AudioBuffer with reverb if available, otherwise fallback to HTMLAudioElement
                    playNeonBlinkSoundWithReverb();
                }
                
                // Turn on the light
                element.classList.add('lit');
                
                function doBlink() {
                    // Check again if still in hero-section
                    const heroSection = document.querySelector('.hero-section');
                    if (!heroSection || !heroSection.contains(element)) {
                        element.classList.remove('lit');
                        return;
                    }
                    
                    if (currentBlink < blinkCount) {
                        currentBlink++;
                        // Small delay between blinks
                        const timerId = setTimeout(doBlink, 200);
                        activeNeonBlinkTimers.add(timerId);
                    } else {
                        // After all blinks, turn off
                        const timerId = setTimeout(() => {
                            element.classList.remove('lit');
                            activeNeonBlinkTimers.delete(timerId);
                        }, 600); // Duration of blink animation
                        activeNeonBlinkTimers.add(timerId);
                    }
                }
                
                // Start blinking after a short delay
                const timerId = setTimeout(() => {
                    doBlink();
                    activeNeonBlinkTimers.delete(timerId);
                }, 100);
                activeNeonBlinkTimers.add(timerId);
            }
            
            // Schedule blinking for each part independently
            burntParts.forEach((element, index) => {
                // Different initial delay for each part (asynchronous)
                const initialDelay = 3000 + Math.random() * 2000 + (index * 800);
                
                function scheduleNextLight() {
                    // Check if element is still in hero-section
                    const heroSection = document.querySelector('.hero-section');
                    if (!heroSection || !heroSection.contains(element)) {
                        return;
                    }
                    
                    const delay = 2000 + Math.random() * 2000; // 2-4 seconds between lights
                    const timerId = setTimeout(() => {
                        triggerLight(element);
                        scheduleNextLight();
                        activeNeonBlinkTimers.delete(timerId);
                    }, delay);
                    activeNeonBlinkTimers.add(timerId);
                }
                
                // Start after initial delay
                const timerId = setTimeout(() => {
                    scheduleNextLight();
                    activeNeonBlinkTimers.delete(timerId);
                }, initialDelay);
                activeNeonBlinkTimers.add(timerId);
            });
        }

        // Initialize section indicator on load
        function initializePage() {
            initSounds();
            
            // Activate audio on first user interaction (mouse movement counts as interaction)
            const playInitOnInteraction = () => {
                activateAudioAndPlayInit();
            };
            
            // For mobile devices, prioritize touch events to ensure audio context is activated
            const isMobile = window.innerWidth <= 768 || 'ontouchstart' in window;
            
            if (isMobile) {
                // On mobile, activate audio on touchstart (most reliable)
                document.addEventListener('touchstart', playInitOnInteraction, { once: true, passive: true });
                document.addEventListener('touchend', playInitOnInteraction, { once: true, passive: true });
                document.addEventListener('click', playInitOnInteraction, { once: true });
            } else {
                // On desktop, use mousemove as primary trigger - it's the least intrusive interaction
                document.addEventListener('mousemove', playInitOnInteraction, { once: true });
                document.addEventListener('click', playInitOnInteraction, { once: true });
            }
            
            // Fallback events for all devices
            document.addEventListener('keydown', playInitOnInteraction, { once: true });
            document.addEventListener('pointerdown', playInitOnInteraction, { once: true });
            
            initSectionIndicator();
            initCustomCursor();
            initSectionClickHandlers();
            initControlButtons();
            initGlitchEffect();
            
            // Start background music after user interaction (if not muted)
            const startBackgroundMusic = () => {
                if (backgroundMusic && !soundMuted) {
                    backgroundMusic.play().catch(() => {
                        // Silent fail - may require user interaction
                    });
                }
            };
            
            // Start music on first user interaction
            document.addEventListener('click', startBackgroundMusic, { once: true });
            document.addEventListener('touchstart', startBackgroundMusic, { once: true });
            document.addEventListener('keydown', startBackgroundMusic, { once: true });
            
            // Initialize current section and start animations
            requestAnimationFrame(() => {
                const initialIndex = getCurrentSectionIndex();
                currentSectionIndex = initialIndex;
                handleSectionChange(initialIndex, -1);
            });
        }
        
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initializePage);
        } else {
            initializePage();
        }

        // Fullscreen mode function (optional - can be triggered manually if needed)
        function initFullscreen() {
            function requestFullscreen() {
                const element = document.documentElement;
                
                if (element.requestFullscreen) {
                    element.requestFullscreen().catch(() => {
                        // Silent fail - fullscreen requires user gesture
                    });
                } else if (element.webkitRequestFullscreen) {
                    element.webkitRequestFullscreen();
                } else if (element.mozRequestFullScreen) {
                    element.mozRequestFullScreen();
                } else if (element.msRequestFullscreen) {
                    element.msRequestFullscreen();
                }
            }

            // Only request fullscreen if user explicitly wants it
            // Removed automatic request to avoid permission errors

            // Add class and hide scrollbar when fullscreen is active
            function handleFullscreenChange() {
                const isFullscreen = document.fullscreenElement || 
                                    document.webkitFullscreenElement || 
                                    document.mozFullScreenElement || 
                                    document.msFullscreenElement;
                
                if (isFullscreen) {
                    document.body.classList.add('fullscreen-active');
                    document.documentElement.classList.add('fullscreen-active');
                    // Force hide scrollbar via inline styles
                    document.body.style.scrollbarWidth = 'none';
                    document.body.style.msOverflowStyle = 'none';
                    document.documentElement.style.scrollbarWidth = 'none';
                    document.documentElement.style.msOverflowStyle = 'none';
                } else {
                    document.body.classList.remove('fullscreen-active');
                    document.documentElement.classList.remove('fullscreen-active');
                }
            }

            document.addEventListener('fullscreenchange', handleFullscreenChange);
            document.addEventListener('webkitfullscreenchange', handleFullscreenChange);
            document.addEventListener('mozfullscreenchange', handleFullscreenChange);
            document.addEventListener('MSFullscreenChange', handleFullscreenChange);
        }

        // Initialize fullscreen handlers (but don't request fullscreen automatically)
        initFullscreen();

        // Fullscreen toggle function
        function toggleFullscreen() {
            const element = document.documentElement;
            const isFullscreen = document.fullscreenElement || 
                                document.webkitFullscreenElement || 
                                document.mozFullScreenElement || 
                                document.msFullscreenElement;
            
            if (!isFullscreen) {
                // Enter fullscreen
                if (element.requestFullscreen) {
                    element.requestFullscreen().catch(() => {
                        // Silent fail
                    });
                } else if (element.webkitRequestFullscreen) {
                    element.webkitRequestFullscreen();
                } else if (element.mozRequestFullScreen) {
                    element.mozRequestFullScreen();
                } else if (element.msRequestFullscreen) {
                    element.msRequestFullscreen();
                }
            } else {
                // Exit fullscreen
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                } else if (document.webkitExitFullscreen) {
                    document.webkitExitFullscreen();
                } else if (document.mozCancelFullScreen) {
                    document.mozCancelFullScreen();
                } else if (document.msExitFullscreen) {
                    document.msExitFullscreen();
                }
            }
        }

        // Sound mute toggle function
        function toggleSound() {
            // Activate audio context on mobile when user clicks sound button
            if (!audioContext) {
                initSounds();
            }
            if (audioContext && audioContext.state === 'suspended') {
                audioContext.resume().catch(() => {
                    // Silent fail
                });
            }
            
            soundMuted = !soundMuted;
            
            // Control background music
            if (backgroundMusic) {
                if (soundMuted) {
                    backgroundMusic.pause();
                } else {
                    // Try to play background music
                    backgroundMusic.play().catch(() => {
                        // Silent fail - may require user interaction
                    });
                }
            }
            
            const muteBtn = document.getElementById('mute-btn');
            if (muteBtn) {
                if (soundMuted) {
                    muteBtn.textContent = '[SOUND OFF]';
                    muteBtn.classList.add('muted');
                } else {
                    muteBtn.textContent = '[SOUND ON]';
                    muteBtn.classList.remove('muted');
                }
            }
        }

        // Initialize control buttons
        function initControlButtons() {
            const fullscreenBtn = document.getElementById('fullscreen-btn');
            const muteBtn = document.getElementById('mute-btn');
            
            if (fullscreenBtn) {
                fullscreenBtn.addEventListener('click', toggleFullscreen);
            }
            
            if (muteBtn) {
                muteBtn.addEventListener('click', toggleSound);
            }
            
            // Update fullscreen button text based on current state
            function updateFullscreenButton() {
                const isFullscreen = document.fullscreenElement || 
                                    document.webkitFullscreenElement || 
                                    document.mozFullScreenElement || 
                                    document.msFullscreenElement;
                if (fullscreenBtn) {
                    fullscreenBtn.textContent = isFullscreen ? '[EXIT FS]' : '[FULLSCREEN]';
                }
            }
            
            // Listen for fullscreen changes
            document.addEventListener('fullscreenchange', updateFullscreenButton);
            document.addEventListener('webkitfullscreenchange', updateFullscreenButton);
            document.addEventListener('mozfullscreenchange', updateFullscreenButton);
            document.addEventListener('MSFullscreenChange', updateFullscreenButton);
        }

        // Track current section for animation control (initialized in scroll handler)
        let currentSectionIndex = -1;
        let previousSectionIndex = -1;
        let neonBlinkInitialized = false;
        
        // Get section element by index
        function getSectionByIndex(index) {
            const heroSection = document.querySelector('.hero-section');
            const regularSections = Array.from(document.querySelectorAll('.section:not(.hero-section)'));
            const allSections = heroSection ? [heroSection, ...regularSections] : regularSections;
            return allSections[index] || null;
        }
        
        // Handle section change - stop previous animations and start new ones
        function handleSectionChange(newIndex, oldIndex) {
            // Stop sounds from previous section
            stopAllSounds();
            
            // Stop animations from previous section
            if (oldIndex >= 0) {
                const oldSection = getSectionByIndex(oldIndex);
                if (oldSection) {
                    // Stop typing animations
                    if (currentTypingSection === oldSection) {
                        stopAllTypingAnimations();
                        currentTypingSection = null;
                    }
                    // Remove terminal-reveal class to allow restart on return
                    oldSection.classList.remove('terminal-reveal');
                }
                
                // If leaving hero-section, stop neon blink and terminal animation
                if (oldIndex === 0) {
                    if (neonBlinkInitialized) {
                        stopNeonBlinkEffect();
                        neonBlinkInitialized = false;
                    }
                    // Stop terminal animation
                    stopTerminalAnimation();
                }
            }
            
            // Start animations for new section
            if (newIndex >= 0) {
                const newSection = getSectionByIndex(newIndex);
                if (newSection) {
                    // Handle hero-section (index 0) - start neon blink and terminal animation
                    if (newIndex === 0) {
                        // Start neon blink if not already initialized
                        if (!neonBlinkInitialized) {
                            neonBlinkInitialized = true;
                            initNeonBlinkEffect();
                        }
                        
                        // Restart terminal animation (only if not already running for this section)
                        if (commandText && terminalOutput) {
                            // If terminal is already running for this section, don't restart
                            if (terminalSectionIndex === 0 && terminalAnimationActive) {
                                return;
                            }
                            
                            // Stop any existing terminal animation first
                            stopTerminalAnimation();
                            terminalSectionIndex = -1;
                            
                            // Also stop all typing animations to ensure clean state
                            if (commandText._cancelTyping) {
                                commandText._cancelTyping();
                            }
                            
                            // Clear terminal
                            commandText.textContent = '';
                            terminalOutput.innerHTML = '';
                            
                            // Small delay to ensure previous animation is fully stopped
                            setTimeout(() => {
                                // Double check that animation is stopped and start fresh
                                if (terminalAnimationActive) {
                                    stopTerminalAnimation();
                                }
                                // Ensure clean state
                                terminalAnimationActive = false;
                                currentTechIndex = 0;
                                
                                // Now start fresh
                                terminalSectionIndex = 0;
                                terminalAnimationActive = true;
                                showTechnology(0);
                            }, 200);
                        }
                    }
                    
                    // Handle regular sections - start typing animation
                    if (!newSection.classList.contains('hero-section')) {
                        if (!newSection.classList.contains('terminal-reveal')) {
                            newSection.classList.add('terminal-reveal');
                            prepareTypingElements(newSection);
                            setTimeout(() => {
                                typeSectionContent(newSection);
                            }, 600);
                        }
                    }
                }
            }
        }
        
        // Simple scroll binding - update indicator and handle section changes
        window.addEventListener('scroll', () => {
            const currentIndex = getCurrentSectionIndex();
            updateSectionIndicator(currentIndex);
            
            // Check if section changed (only if not currently programmatically scrolling)
            if (currentIndex !== currentSectionIndex && !isScrolling) {
                previousSectionIndex = currentSectionIndex;
                currentSectionIndex = currentIndex;
                handleSectionChange(currentIndex, previousSectionIndex);
            }
        }, { passive: true });

        // Custom hacker green cursor
        function initCustomCursor() {
            const cursor = document.createElement('div');
            cursor.className = 'custom-cursor';
            
            // Create SVG cursor arrow - standard pointer style
            const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            svg.setAttribute('viewBox', '0 0 24 24');
            svg.setAttribute('width', '24');
            svg.setAttribute('height', '24');
            svg.setAttribute('xmlns', 'http://www.w3.org/2000/svg');
            
            // Main arrow triangle
            const arrow = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            arrow.setAttribute('d', 'M 3 3 L 3 13 L 6 10 L 9 19 L 11 18 L 8 9 L 12 9 L 3 3 Z');
            arrow.setAttribute('fill', '#00ff00');
            
            // Arrow outline/shadow for better visibility
            const outline = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            outline.setAttribute('d', 'M 3 3 L 3 13 L 6 10 L 9 19 L 11 18 L 8 9 L 12 9 L 3 3 Z');
            outline.setAttribute('fill', 'none');
            outline.setAttribute('stroke', '#00ff41');
            outline.setAttribute('stroke-width', '0.5');
            
            svg.appendChild(outline);
            svg.appendChild(arrow);
            cursor.appendChild(svg);
            document.body.appendChild(cursor);

            let cursorX = 0;
            let cursorY = 0;
        let mouseX = 0;
        let mouseY = 0;

            // Update cursor position
        document.addEventListener('mousemove', (e) => {
                mouseX = e.clientX;
                mouseY = e.clientY;
            });

            // Smooth cursor animation
            function animateCursor() {
                cursorX += (mouseX - cursorX) * 0.15;
                cursorY += (mouseY - cursorY) * 0.15;
                cursor.style.left = cursorX + 'px';
                cursor.style.top = cursorY + 'px';
                requestAnimationFrame(animateCursor);
            }
            animateCursor();

            // Cursor hover effects
            const hoverElements = document.querySelectorAll('a, button, .section-number, .project-link, .contact-link, .control-button');
            hoverElements.forEach(el => {
                el.addEventListener('mouseenter', () => {
                    cursor.classList.add('hover');
                });
                el.addEventListener('mouseleave', () => {
                    cursor.classList.remove('hover');
                });
            });

            // Cursor click effect
            document.addEventListener('mousedown', () => {
                cursor.classList.add('click');
            });
            document.addEventListener('mouseup', () => {
                cursor.classList.remove('click');
            });
        }

        // Click handler for section numbers in wheel
        function initSectionClickHandlers() {
            const sectionNumbers = document.querySelectorAll('.section-number');
            sectionNumbers.forEach((el) => {
                const index = parseInt(el.getAttribute('data-index'));
                if (!isNaN(index)) {
                    el.addEventListener('click', (e) => {
                        e.stopPropagation();
                        scrollToSection(index);
                    });
                }
            });
        }
    </script>
</body>
</html>